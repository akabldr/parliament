# 怎样实现一个高可用的分布式key-value存储服务
[代码](https://github.com/z42y/parliament)
## 起因

由于各种原因，某些软件系统会使用多台机器完成相关任务，但是很多人对“为解决问题而使用多台机器”、和“解决多台机器带来的问题”两者的区别及先后顺序并不清楚。

常常有人将SOA、微服务与分布式系统混淆，在系统实现中先带来不必要的问题，然后又给出不完美的方案。

这篇文档通过一个kv服务java实现的例子，使读者能区分问题和方案，讲解部分分布式理论知识和理论约束，并通过以上仓库的代码、javadoc，讲解一下分布式系统的主要实现细节，
对分布式系统设计和实现的挑战有一个初步认识。

虽然本人尽量以生产环境的可靠性、正确性来实现这个kv服务，但精力、能力有限，某些细节会比较粗糙，可能有bug，并且不会提供相关运维工具的设计和实现。
读者可以自己补充、完善，进行各种测试、试验。

### kv服务功能
这个kv服务实现了PUT、GET、DEL、RANGE（范围查询）命令，使用redis的二进制协议为客户端提供服务，所以可以使用redis-cli连接服务器进行演示。
key排序使用字节数组的字典序。如：

```bash
bash#: redis-cli -p 18001
127.0.0.1:18001> put a A
(integer) 1
127.0.0.1:18001> put b B
(integer) 1
127.0.0.1:18001> range a c
1) "A"
2) "B"
127.0.0.1:18001> del b
(integer) 1
127.0.0.1:18001> get b
(nil)
```

### 运行要求及IDE配置
请查看代码库README文件。

## 问题是什么

> 一个好问题胜过十个好答案。

实现一个key-value单机服务只需三步：
1. 打开端口，监听客户端请求。
2. 接收请求，调用存储引擎处理。
3. 从网络返回处理结果。
非常简单☺。

但随着客户增多，导致我们单机服务的硬盘、内存、CPU都不够用了，用户开始抱怨，如何解决？

### 解决容量限制：扩容
好在客户之间数据没有任何关系，所以可以对不同客户在不同机房和机器上部署独立的kv服务实例，
只需在迁移时暂停一段时间服务。
TODO 图

随着业务发展，某些客户的数据越来越多，导致独立的服务器也无法满足其容量、性能要求了，所以我们对数据进行分片（sharding)，新增一个代理，把这个客户的数据读写操作通过某个规则（如key值范围）转发到不同服务器上进行读写。
TODO 图

但是我们低估了该用户的增长速度，这些机器很快也不够用了，如果新增机器，必然要修改切片规则，如何保证代理进程能够正确的访问新机器并迁移相关数据到新机器上面？
这经常使用[一致性hash](https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C)技术。

### 高可用：灾备
TODO 完全可用的分析
接着出现了某个客户，数据量不大，但是要求一年内99.9999%的服务**可用性**，这意味着一年中服务只有一个小时不可访问。

导致服务不可访问的原因会很多，电力故障、各种机器硬件故障、机房网络故障、操作系统更新导致的重启、运维故障等等。

历史上，工业界对这个问题早就有了答案：灾备，即当使用中的组件出现故障时，使用提前准备好的备份组件进行替换。

于是我们在另一个机房为以上客户部署了一套备份服务，并让客户端在主服务不可用时，自动切换到备份服务上去。
显然，我们也要修改主服务，使其更新数据后，立刻将更新**同步**到灾备。

但是，如果主服务put某条数据后立刻宕机，灾备不会收到该数据的更新，客户切换到灾备则会导致更新丢失，从而出现bug。

假如客户使用kv服务记录用户缴费情况，决定是否提供某些服务，以上情况将会导致用户缴费成功，但是依然无法使用相关服务。

TODO 如何引出时钟问题，各种一致性问题

```
// 服务缴费
put(user_acc, 200); // 成功返回
...
// 发生灾备切换
// 检查余额大于0方能提供服务
if(get(user_acc) > 0) {
	service(user_acc); // 不会执行，产生用户投诉
}

```

对这个问题，一个直观的想法是要求主服务在收到备份服务的响应后，再返回结果给客户端。

但如果灾备本身宕机，或主备之间网络发生异常，此时只有两种方案：

1. 要么超时返回异常。
2. 要么无限制的发生阻塞，直到灾备服务恢复。

无论哪种方案，都不能保证服务的高可用。

既然灾备本身就容易出现故障，那么我们准备多个灾备服务呢？

### 异步系统

我们先在多个机房部署多套灾备服务，现在我们要解决以下问题：

1. 只要有可用的灾备服务，对用户的响应不会无限制的被阻塞。
2. 灾备切换后，用户可以读到灾备切换前所有“写类型操作”（put、del）的结果。

我们把1称为可用性（Availability），用户可以在某个有限时间内获得响应。
对于2，属于计算机中的一致性问题（Consistency）。

如果你写过并发程序，对一致性问题应该不会陌生。以java为例，如果在一个线程中修改了一个对象，
另一个线程在之后可能无法感知这个修改，需要使用各种**同步**语义（如volatile、synchronized关键字）保证对象在各个线程中同步。

因为多核系统，每个cpu内核都有各自的独立高速缓存，程序在运行时，为了效率，会先将经常使用的内存内容放到高速缓存中操作，稍后再刷新到内存中。
同时，编译器或vm会对内存的修改顺序进行修改，以便优化执行速度。

每种支持并发的语言对内存一致性都有相关的语义和操作约束，叫做内存模型，比如java memory model规定了jvm什么时候能够保证哪些对象修改对其他线程可见，
或者对内存操作的顺序有什么保证。

这和我们的灾备系统有什么关系呢？本质上，灾备系统也是多个cpu对各自独立内存的修改，我们要保证某个修改对其他硬件上的内存可见。

多核cpu有各种指令保证内存刷新同步，我们灾备的同步操作可以类比为这些内存刷新指令，但是两者有一个根本区别：

***多核cpu是同步系统，我们灾备架构是异步系统***。

1. 同步系统意味着操作如果在一定时间没有返回，则可以安全的认为操作失败。
2. 异步系统的操作在一定时间没有返回，我们无法判断是否失败，还是操作的响应丢失了。

多核cp指令失败，那么系统肯定不会正常运行，一般这种情况系统会宕机。
如果cpu出现硬件故障，操作系统和进程依然在运行的情况是存在的，这种问题会非常棘手，通常完全宕掉的系统比半死不活的系统好得多。

灾备系统之间的TCP/IP网络就是异步的，如果一个系统向另一个系统发送了put操作，没有收到响应，此时：

2. 可能对方宕机了。
3. 可能消息出现了延迟。
4. 网络设备把消息丢了。

宕机和网络故障时等价的，同时我们无法区分消息延迟和宕机。在这个前提下，能否设计出一个***100%***可用，且满足***一致性***的异步系统呢？

## leader机制
我们假设主系统宕机后，系统从各个灾备节点中选举一个新的节点（leader）提供服务。新的节点必须有最新的数据。
我们可以对每个操作进行编号，保证编号一直递增，节点收到请求后保存在本地，灾备节点相互通信选出一个当前编号最大的节点做为leader。

有各种leader选举算法可以应用。

## quorum机制

## 鱼和熊掌不可兼得：CAP和PACELC


### 各种一致性定义 

## 答案能有多完美
## 实现共识算法

## 实现复制状态机

## 实现网络协议

## 实现kv服务

## 实现可靠的存储引擎
